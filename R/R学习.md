# R学习

to see the Rstiduo environment 

```r
devtools::session_info()
###the follow are the results of R environment
─ Session info ──────────────────────────────────────────────────────────────────────
 setting  value                       
 version  R version 4.1.0 (2021-05-18)
 os       Ubuntu 18.04.5 LTS          
 system   x86_64, linux-gnu           
 ui       RStudio                     
 language (EN)                        
 collate  en_US.UTF-8                 
 ctype    en_US.UTF-8                 
 tz       Asia/Shanghai               
 date     2021-05-28                  

─ Packages ──────────────────────────────────────────────────────────────────────────
 package              * version  date       lib source        
 Biobase                2.51.0   2021-03-19 [2] Bioconductor  
 BiocGenerics           0.37.6   2021-05-11 [2] Bioconductor  
 BiocManager            1.30.15  2021-05-11 [2] CRAN (R 4.1.0)
 BiocParallel           1.25.5   2021-03-19 [2] Bioconductor  
 Biostrings             2.59.4   2021-05-14 [2] Bioconductor  
 bitops                 1.0-7    2021-04-24 [2] CRAN (R 4.1.0)
 cachem                 1.0.5    2021-05-15 [2] CRAN (R 4.0.5)
 callr                  3.7.0    2021-04-20 [2] CRAN (R 4.0.5)
 cli                    2.5.0    2021-04-26 [2] CRAN (R 4.0.5)
 crayon                 1.4.1    2021-02-08 [2] CRAN (R 4.0.5)
 DelayedArray           0.17.13  2021-05-02 [2] Bioconductor  
 desc                   1.3.0    2021-03-05 [2] CRAN (R 4.0.5)
 devtools               2.4.1    2021-05-05 [2] CRAN (R 4.1.0)
 ellipsis               0.3.2    2021-04-29 [2] CRAN (R 4.0.5)
 fastmap                1.1.0    2021-01-25 [2] CRAN (R 4.0.5)
 fs                     1.5.0    2020-07-31 [2] CRAN (R 4.0.5)
 GenomeInfoDb           1.27.13  2021-05-14 [2] Bioconductor  
 GenomeInfoDbData       1.2.6    2021-05-20 [2] Bioconductor  
 GenomicAlignments      1.27.2   2021-03-19 [2] Bioconductor  
 GenomicRanges          1.43.4   2021-04-04 [2] Bioconductor  
 glue                   1.4.2    2020-08-27 [2] CRAN (R 4.0.5)
 hwriter                1.3.2    2014-09-10 [2] CRAN (R 4.1.0)
 IRanges                2.25.11  2021-05-05 [2] Bioconductor  
 jpeg                   0.1-8.1  2019-10-24 [2] CRAN (R 4.1.0)
 lattice                0.20-44  2021-05-02 [4] CRAN (R 4.0.5)
 latticeExtra           0.6-29   2019-12-19 [2] CRAN (R 4.1.0)
 lifecycle              1.0.0    2021-02-15 [2] CRAN (R 4.0.5)
 magrittr               2.0.1    2020-11-17 [2] CRAN (R 4.0.5)
 Matrix                 1.3-3    2021-05-04 [4] CRAN (R 4.0.5)
 MatrixGenerics         1.3.1    2021-03-19 [2] Bioconductor  
 matrixStats            0.58.0   2021-01-29 [2] CRAN (R 4.1.0)
 memoise                2.0.0    2021-01-26 [2] CRAN (R 4.0.5)
 pkgbuild               1.2.0    2020-12-15 [2] CRAN (R 4.0.5)
 pkgload                1.2.1    2021-04-06 [2] CRAN (R 4.0.5)
 png                    0.1-7    2013-12-03 [2] CRAN (R 4.1.0)
 prettyunits            1.1.1    2020-01-24 [2] CRAN (R 4.0.5)
 processx               3.5.2    2021-04-30 [2] CRAN (R 4.0.5)
 ps                     1.6.0    2021-02-28 [2] CRAN (R 4.0.5)
 purrr                  0.3.4    2020-04-17 [2] CRAN (R 4.0.5)
 R6                     2.5.0    2020-10-28 [2] CRAN (R 4.0.5)
 RColorBrewer           1.1-2    2014-12-07 [2] CRAN (R 4.1.0)
 RCurl                  1.98-1.3 2021-03-16 [2] CRAN (R 4.1.0)
 remotes                2.3.0    2021-04-01 [2] CRAN (R 4.0.5)
 rlang                  0.4.11   2021-04-30 [2] CRAN (R 4.0.5)
 rprojroot              2.0.2    2020-11-15 [2] CRAN (R 4.0.5)
 Rsamtools              2.7.2    2021-04-10 [2] Bioconductor  
 rstudioapi             0.13     2020-11-12 [2] CRAN (R 4.0.5)
 S4Vectors              0.29.19  2021-05-06 [2] Bioconductor  
 sessioninfo            1.1.1    2018-11-05 [2] CRAN (R 4.0.5)
 ShortRead              1.49.3   2021-05-17 [2] Bioconductor  
 SummarizedExperiment   1.21.3   2021-04-07 [2] Bioconductor  
 testthat               3.0.2    2021-02-14 [2] CRAN (R 4.0.5)
 usethis                2.0.1    2021-02-10 [2] CRAN (R 4.1.0)
 withr                  2.4.2    2021-04-18 [2] CRAN (R 4.0.5)
 XVector                0.31.1   2021-03-19 [2] Bioconductor  
 zlibbioc               1.37.0   2021-03-19 [2] Bioconductor  

[1] /wrk/yuanzhen/R/x86_64-pc-linux-gnu-library/4.1
[2] /usr/local/lib/R/site-library
[3] /usr/lib/R/site-library
[4] /usr/lib/R/library
```



you can use Rstiduo to make your own "project" to analysis your data,and every "project" has its own work folder.

you can invoke a scripts by `source ("XXX.r")`

还可以选择扩展包的安装路径， 如果权限允许， 可以选择安装在R软件的主目录内或者用户自己的私有目录位置。 由于用户的对子目录的读写权限问题， 有时不允许一般用户安装扩展包到R的主目录中。 用`.libPaths()`查看允许的扩展包安装位置， 在`install.packages()`中用`lib=`指定安装位置：

```R
print(.libPaths())
## [1] "/wrk/yuanzhen/R/x86_64-pc-linux-gnu-library/4.1"
## [2] "/usr/local/lib/R/site-library"                  
## [3] "/usr/lib/R/site-library"                        
## [4] "/usr/lib/R/library"
install.packages("DESeq2", lib=.libPaths()[1])
```



我们做生物信息学分析时，可以充分利用[Github](https://github.com/deeptools/pyBigWig)和[BioConductor](https://bioconductor.org/packages/release/bioc/html/DESeq2.html)的扩展包

```R
### from github
if(!require(devtools)) install.packages('devtools')
devtools::install_github("kjhealy/socviz")
### from bioconductor
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install(c("Biostrings"))
```



在RStudio中用“Tools–Check for Package Updates”菜单， 可以显示有新版本的扩展包， 并选择进行更新。

或者在命令行用如下命令更新本地安装的所有有新版本的CRAN扩展包

```r
options(repos=c(CRAN="http://mirror.tuna.tsinghua.edu.cn/CRAN/"))
update.packages(checkBuilt=TRUE, ask=FALSE)
```

可能在Rstiduo中无法更新的需要在R中更新



在每一次R软件更新后， 需要重新安装原来的软件包， 这个过程很麻烦。 如果仅仅是小的版本更新， 比如从3.5.1变成3.5.2， 或者从3.4.2变成3.5.0， 可以在安装新版本后， 临时将新版本的library子目录更名为library0， 将老版本的library子目录剪切为新版本的library子目录， 然后将library0中所有内容复制并覆盖进入library子目录， 删除library0即可。 然后在基本R中（不要用RStudio）运行如下命令以更新有新版本的包：



```R
options(repos=c(CRAN="http://mirror.tuna.tsinghua.edu.cn/CRAN/"))
update.packages(checkBuilt=TRUE, ask=FALSE)
```

如果版本改变比较大， 可以用如下方法批量地重新安装原有的软件包。 首先，在更新R软件前，在原来的R中运行：



```r
packages <- .packages(TRUE)
dump("packages", file="packages-20180704.R")
```

这样可以获得要安装的软件包的列表。 在更新R软件后， 运行如下程序：



```
options(repos=c(CRAN="http://mirror.tuna.tsinghua.edu.cn/CRAN/"))
source("packages-20180704.R")
install.packages(packages)
```

安装时如果提问是否安装需要编译的源代码包， 最好选择否， 因为安装源代码包速度很慢还有可能失败。



在MS Windows操作系统中， 默认的中文编码是GB18030编码。 R源程序文件的中文编码可能是GB18030也可能是UTF-8。 UTF-8是在世界范围更通用的编码。 如果发现用如下命令运行时出现中文乱码， 可能是因为源程序用了UTF-8编码， 这时`source()`命令要加上编码选项如下：

```R
source("myprog.R", encoding="UTF-8")
```

界面一般分为四个窗格， 其中编辑窗口与控制台（Console）是最重要的两个窗格。 编辑窗格用来查看和编辑程序、文本型的数据文件、程序与文字融合在一起的Rmd文件等。 控制台与基本R软件的命令行窗口基本相同， 功能有所增强。

在编辑窗口中可以用操作系统中常用的编辑方法对源文件进行编辑， 如复制、粘贴、查找、替换， 还支持基于正则表达式的查找替换.

其它的一些重要窗格包括：

- Files: 列出当前项目的目录（文件夹）内容。 其中以`.R`或者`.r`为扩展名的是R源程序文件， 单击某一源程序文件就可以在编辑窗格中打开该文件。
- Plots: 如果程序中有绘图结果， 将会显示在这个窗格。 因为绘图需要足够的空间， 所以当屏幕分辨率过低或者Plots窗格太小的时候， 可以点击“Zoom”图标将图形显示在一个单独的窗口中， 或者将图形窗口作为唯一窗格显示。 如何放大窗格见下面的使用技巧。
- Help: R软件的文档与RStudio的文档都在这里。
- Environment: 已经有定义的变量、函数都显示在这里。
- History: 以前运行过的命令都显示在这里。 不限于本次RStdudio运行期间， 也包括以前使用RStudio时运行过的命令。
- Packages: 显示已安装的R扩展包及其文档。
- Viewer, Connection, Build, Git等窗格。





在命令行，用问号后面跟随函数名查询某函数的帮助。 用`example(`函数名`)`的格式可以运行此函数的样例，如:

```R
example(mean)
## 
## mean> x <- c(0:10, 50)
## 
## mean> xm <- mean(x)
## 
## mean> c(xm, mean(x, trim = 0.10))
## [1] 8.75 5.50

```



有时仅知道一些方法的名字而不知道具体的扩展包和函数名称， 可以安装sos扩展包（package）， 用`findFn("函数名")`查询某个函数， 结果显示在互联网浏览器软件中。



在控制台（命令行窗格）中， 除了可以用左右光标键移动光标位置， 用上下光标键调回以前运行过的命令， 还有一个重要的增强（以MS Windows操作系统为例）： 键入要运行的命令的前几个字母，如`book`， 按“Ctrl+向上光标键”， 就可以显示历史命令中以`book`开头的所有命令， 单击哪一个， 哪一个就自动复制到命令行。 这一技巧十分重要， 我们需要反复允许同一命令时， 这一方法让我们很容易从许多命令历史中找到所需的命令。



当屏幕分辨率较低时， 将整个RStudio界面分为四个窗格会使得每个窗格都没有足够的显示精度。 为此， 可以将某个窗格放大到整个窗口区域， 需要使用其它窗格时再恢复到四个窗格的状态或者直接放大其它窗格到整个窗口区域。

使用菜单“View – Panes – Zoom Source”可以将编辑窗格放到最大， 在MS Windows下也可以使用快捷键“Ctrl+Alt+1”。 其它操作系统也有类似的快捷键可用。 使用菜单“View – Panes – Show All Panes”可以显示所有四个窗格。

放大其它窗格也可以用“Ctrl + Alt + 数字”，数字与窗格的对应关系为：

- 1: 编辑窗格；
- 2: 控制台（Console）；
- 3: 帮助；
- 4: 历史；
- 5: 文件；
- 6: 图形；
- 7: 扩展包；
- 8: 已定义变量和函数；
- 9: 研究报告或网站结果显示。



编写R程序的正常做法是一边写一遍试验运行， 运行一般不是整体的运行而是写完一部分就运行一部分， 运行没有错误才继续编写下一部分。 在R源程序窗口中， 当光标在某一程序上的时候， 点击窗口的“Run”快捷图标或者用快捷键“Ctrl+Enter键”可以运行该行； 选中若干程序行后， 点击窗口的“Run”快捷图标或者用快捷键“Ctrl+Enter键”可以运行这些行。



对于中文内容的R源程序、R Markdown源文件（.Rmd文件）、文本型数据文件(.txt，.csv)， 其中的中文内容可能有不同的编码选择， 在中国国内主要使用GB18030(基本兼容于GB, GBK)和UTF-8， UTF-8是国际上更普遍使用的统一文字编码， 涉及到计算机编程时应尽可能使用此编码系统。

在RStudio中新生成的R源程序、Rmd源文件一般自动用UTF-8编码。 点击RStudio的文件窗格中显示的源文件， 可以打开该源文件， 但是因为已有源文件的编码不一定与RStudio的默认编码一致， 可以会显示成乱码。 为此， RStdio提供了“File – Reopen with Encoding”命令， 我们主要试验其中GB18030和UTF-8两种选择一般就可以解决问题。 如果选择GB18030显示就没有乱码了， 最好再用菜单“File – Save with Encoding”并选择UTF-8将其保存为UTF-8编码。



``` R
sqrt(6.25)
## [1] 2.5   平方根
 
exp(1)
### [1] 2.718282  指数e

log10(10000)
## [1] 4   对数
```

取整数

```R
round(1.1234, 2)
## [1] 1.12
round(-1.9876, 2)
## [1] -1.99
floor(1.1234)
## [1] 1
floor(-1.1234)
## [1] -2
ceiling(1.1234)
## [1] 2
ceiling(-1.1234)
## [1] -1
```





```R
dnorm(1.98)
## [1] 0.05618314  标准正态分布密度
pnorm(1.98)
## [1] 0.9761482   标准正态分布函数
qnorm(0.975)
## [1] 1.959964    标准正态分布分位数函数
```



求自由度为10的t检验的双侧临界值。 其中`qt(y,df)`表示自由度为`df`的t分布的分位数函数。



#### 简单的输出

命令行的计算结果直接显示在命令的后面。 在用`source()`运行程序文件时， 需要用`print()`函数显示一个表达式的结果，如：



```R
print(sin(pi/2))
## [1] 1
```

用`cat()`函数显示多项内容， 包括数值和文本， 文本包在两个单撇号或两个双撇号中，如:



```R
cat("sin(pi/2)=", sin(pi/2), "\n")
## sin(pi/2)= 1 
```

`cat()`函数最后一项一般是`"\n"`, 表示换行。 忽略此项将不换行。

再次提示：要避免打开中文输入法导致误使用中文标点。





R使用经常是在命令行逐行输入命令（程序）， 结果紧接着显示在命令后面。 如何保存这些命令和显示结果？ 在R命令行中运行过的命令会被保存在运行的工作文件夹中的一个名为.Rhistory的文件中。 用`sink()`函数打开一个文本文件开始记录文本型输出结果。 结束记录时用空的`sink()`即可关闭文件不再记录。 如

```R
sink("tmpres01.txt", split=TRUE)
print(sin(pi/6))
print(cos(pi/6))
cat("t(10)的双侧0.05分位数（临界值）=", qt(1 - 0.05/2, 10), "\n")
sink()
```

`sink()`用作输出记录主要是在测试运行中使用， 正常的输出应该使用`cat()`函数、`write.table()`、`write.csv()`等函数。



### 向量计算与变量赋值

R语言以向量为最小单位。用`<-`赋值。如

```R
x1 <- 1:10
x1
##  [1]  1  2  3  4  5  6  7  8  9 10
```

一般的向量可以用`c()`生成， 如

```R
marks <- c(3, 5, 10, 5, 6)
```

在程序语言中，变量用来保存输入的值或计算的结果。 变量可以存放各种不同类型的值， 如单个数值、多个数值（称为向量）、单个字符串、多个字符串（称为字符型向量），等等。 单个数值称为**标量**。

技术秘诀：用程序设计语言的术语描述， R语言是动态类型的， 其变量的类型不需要预先声明， 运行过程中允许变量类型改变， 实际上变量赋值是一种“绑定”（binding）， 将一个变量的名称（变量名）与实际的一个存储位置联系在一起。 在命令行定义的变量称为**全局变量**。

用`print()`函数显示向量或在命令行中显示向量时， 每行显示的行首会有方括号和数字序号， 代表该行显示的第一个向量元素的下标。如



```R
12345678901:12345678920
##  [1] 12345678901 12345678902 12345678903 12345678904 12345678905
##  [6] 12345678906 12345678907 12345678908 12345678909 12345678910
## [11] 12345678911 12345678912 12345678913 12345678914 12345678915
## [16] 12345678916 12345678917 12345678918 12345678919 12345678920
```

向量可以和一个标量作四则运算， 结果是每个元素都和这个标量作四则运算，如：



```R
x1 + 200
## [1] 201 202 203 204 205 206 207 208 209 210
2*x1
## [1]  2  4  6  8 10 12 14 16 18 20
2520/x1
## [1] 2520 1260  840  630  504  420  360  315  280  252
```

两个等长的向量可以进行四则运算， 相当于对应元素进行四则运算，如



```R
x2 <- x1 * 3
x2
## [1]  3  6  9 12 15 18 21 24 27 30
x2 - x1
## [1]  2  4  6  8 10 12 14 16 18 20
```

R的许多函数都可以用向量作为自变量， 结果是自变量的每个元素各自的函数值。 如



```R
sqrt(x1)
## [1] 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490 2.645751
## [8] 2.828427 3.000000 3.162278
```

结果是1到10的整数各自的平方根。



在命令行中定义的变量， 在退出R时，会提问是否保存工作空间， 初学时可选择保存， 真正用R进行数据分析时往往不保存工作空间。 再次启动R后， 能够看到以前定义的各个变量的值。

在使用R的官方版本时， 如果在Windows中使用， 一般把不同的数据分析项目放在不同的文件夹中。 将R的程序快捷图标复制到每一个项目的文件夹中， 并用右键菜单讲快捷图标的“属性”中“起始位置”改为空白。 要分析哪一个项目的数据， 就从那个项目文件夹中的R快捷图标启动， 这样可以保证不同的项目有不同的工作空间。

如果使用RStudio软件， 也需要把不同项目放在不同文件夹， 并且每个项目在RStudio中单独建立一个“项目”（project）。 要分析那个项目的数据， 就打开那个项目。 不同项目使用不同的工作空间。

RStudio中的“Environment”窗格会显示当前已定义的R变量与函数。



用`curve()`函数制作函数的曲线图， `curve()`函数第二、第三自变量是绘图区间：，sin(x)函数曲线图用如下程序可制作, 用`abline()`函数添加参考线:

```R
curve(sin(x), 0, 2*pi)
abline(h=0)
```



统计用的输入数据典型样式是Excel表那样的表格数据。 表格数据特点：每一列应该是相同的类型（或者都是数值， 或者都是文字，或者都是日期）， 每一列应该有一个名字。

这样的表格数据，一般可以保存为.csv格式： 数据项之间用逗号分开，文件本身是文本型的， 可以用普通记事本程序查看和编辑。 Excel表可以用“另存为”命令保存为.csv格式。 常用的数据库管理系统一般也可以把表保存为.csv格式。





在tax.tab中， “征收方式”是一个分类变量。 用`table()`函数计算每个不同值的个数，称为**频数**(frequency):

```R
table(tax.tab[["征收方式"]])
## 
##     查帐征收 定期定额征收 定期定率征收 
##           31           16            2
```

类似地可以统计 “申报渠道”的取值频数:

```R
table(tax.tab[["申报渠道"]])
## 
## 大厅申报 网上申报 
##       18       31
```

也可以用`table()`函数统计“征收方式”和“申报渠道”交叉分类频数，如：

```R
table(tax.tab[["征收方式"]], tax.tab[["申报渠道"]])
##               
##                大厅申报 网上申报
##   查帐征收            9       22
##   定期定额征收        9        7
##   定期定率征收        0        2
```

上述结果制表如下:

```R
knitr::kable(table(tax.tab[["征收方式"]], tax.tab[["申报渠道"]]) )
```



|              | 大厅申报 | 网上申报 |
| ------------ | -------- | -------- |
| 查帐征收     | 9        | 22       |
| 定期定额征收 | 9        | 7        |
| 定期定率征收 | 0        | 2        |







R语言基本的数据类型有数值， 逻辑型（TRUE, FALSE），文本（字符串）。 支持缺失值，有专门的复数类型。

R语言数据结构包括向量，矩阵和数据框，多维数组， 列表，对象等。数据中元素、行、列还可以用名字访问。 最基本的是向量类型。 向量类型数据的访问方式也是其他数据类型访问方式的基础。

数值型变量可以计算各种不同的统计量, 如平均值、标准差和各个分位数。 `summary()`可以给出最小值、最大值、中位数、四分之一分位数、四分之三分位数和平均值。如



```
summary(tax.tab[["营业额"]])
##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##       0     650    2130  247327    9421 6048000
```

中位数是从小到大排序后排在中间的值。 四分之一和四分之三分位数类似。

统计函数以一个数值型向量为自变量， 包括`sum`(求和), `mean`(平均值), `var`(样本方差), `sd`(样本标准差), `min`(最小值), `max`(最大值), `range`(最小值和最大值)等。如



```
mean(tax.tab[["营业额"]])
## [1] 247327.4
```



```
sd(tax.tab[["营业额"]])
## [1] 1036453
```

如果数据中有缺失值， 可以删去缺失值后计算统计量， 这时在`mean`, `sd`等函数中加入`na.rm=TRUE`选项。





##  常量与变量

R语言基本的数据类型有数值型， 逻辑型（TRUE, FALSE），文本（字符串）。 支持缺失值，有专门的复数类型。

常量是指直接写在程序中的值。

数值型常量包括整型、单精度、双精度等，一般不需要区分。写法如`123`, `123.45`, `-123.45`, `-0.012`, `1.23E2`, `-1.2E-2`等。 为了表示`123`是整型，可以写成`123L`。

字符型常量用两个双撇号或两个单撇号包围，如`"Li Ming"`或`'Li Ming'`。 字符型支持中文，如`"李明"`或`'李明'`。 国内的中文编码主要有GBK编码和UTF-8编码， 有时会遇到编码错误造成乱码的问题，MS Windows下R程序一般用GBK编码，但是RStudio软件采用UTF-8编码。 在R软件内字符串一般用UTF-8编码保存。

逻辑型常量只有TRUE和FALSE。

缺失值用NA表示。统计计算中经常会遇到缺失值，表示记录丢失、因为错误而不能用、节假日没有数据等。 除了数值型，逻辑型和字符型也可以有缺失值， 而且字符型的空白值不会自动辨识为缺失值，需要自己规定。 R支持特殊的Inf值，这是实数型值，表示正无穷大，不算缺失值。

复数常量写法如`2.2 + 3.5i`, `1i`等。







变量

程序语言中的变量用来保存输入的值或者计算得到的值。 在R中，变量可以保存所有的数据类型， 比如标量、向量、矩阵、数据框、函数等。

变量都有变量名，R变量名必须以字母、数字、下划线和句点组成， 变量名的第一个字符不能取为数字。 在中文环境下，汉字也可以作为变量名的合法字符使用。 变量名是区分大小写的， `y`和`Y`是两个不同的变量名。

变量名举例: `x`, `x1`, `X`, `cancer.tab`, `clean_data`, `diseaseData`。

用`<-`赋值的方法定义变量。`<-`也可以写成`=`，但是`<-`更直观。 如

```R
x5 <- 6.25
x6 = sqrt(x5)
```

R的变量没有固定的类型， 给已有变量赋值为新的类型， 该变量就变成新的类型， 但一般应避免这样的行为。 R是“动态类型”语言， 赋值实际上是“绑定”（binding）， 即将一个变量名与一个存储地址联系在一起， 同一个存储地址可以有多个变量名与其联系。



### 数据型向量

为了查看这些基础的数学函数的列表，运行命令`help.start()`， 点击链接“Search Engine and Keywords”， 找到“Mathematics”栏目， 浏览其中的“arith”和“math”链接中的说明。 常用的数学函数有：

- 舍入：`ceiling`, `floor`, `round`, `signif`, `trunc`, `zapsmall`
- 符号函数 `sign`
- 绝对值 `abs`
- 平方根 `sqrt`
- 对数与指数函数 `log`, `exp`, `log10`, `log2`
- 三角函数 `sin`, `cos`, `tan`
- 反三角函数 `asin`, `acos`, `atan`, `atan2`
- 双曲函数 `sinh`, `cosh`, `tanh`
- 反双曲函数 `asinh`, `acosh`, `atanh`

有一些不太常用的数学函数：

- 贝塔函数 `beta`, `lbeta`
- 伽玛函数 `gamma`, `lgamma`, `digamma`, `trigamma`, `tetragamma`, `pentagamma`
- 组合数 `choose`, `lchoose`
- 富利叶变换和卷积 `fft`, `mvfft`, `convolve`
- 正交多项式 `poly`
- 求根 `polyroot`, `uniroot`
- 最优化 `optimize`, `optim`
- Bessel函数 `besselI`, `besselK`, `besselJ`, `besselY`
- 样条插值 `spline`, `splinefun`
- 简单的微分 `deriv`

如果自己编写的函数没有考虑向量化问题， 可以用`Vectorize()`函数将其转换成向量化版本。



`sort(x)`返回排序结果。 `rev(x)`返回把各元素排列次序反转后的结果。 `order(x)`返回排序用的下标。如



```
x <- c(33, 55, 11)
sort(x)
## [1] 11 33 55
```



```
rev(sort(x))
## [1] 55 33 11
```



```
order(x)
## [1] 3 1 2
```



```
x[order(x)]
## [1] 11 33 55
```

例子中， `order(x)`结果中3是x的最小元素11所在的位置下标， 1是x的第二小元素33所在的位置下标， 2是x的最大元素55所在的位置下标。





seq函数是冒号运算符的推广。 比如，`seq(5)`等同于`1:5`。 `seq(2,5)`等同于`2:5`。 `seq(11, 15, by=2)`产生11,13,15。 `seq(0, 2*pi, length.out=100)`产生从0到的等间隔序列， 序列长度指定为100。

从这些例子可以看出，S函数可以带自变量名调用。 每个函数的变量名和用法可以查询其帮助信息， 在命令行界面用“?函数名”的方法查询。 在使用变量名时次序可以颠倒， 比如`seq(to=5, from=2)}`仍等同于`2:5`。

`rep()`函数用来产生重复数值。 为了产生一个初值为零的长度为n的向量， 用`x <- rep(0, n)`。 `rep(c(1,3), 2)`把第一个自变量重复两次， 结果相当于`c(1,3,1,3)`。

`rep(c(1,3), c(2,4))`则需要利用R的一般向量化规则， 把第一自变量的第一个元素1按照第二自变量中第一个元素2的次数重复， 把第一自变量中第二个元素3按照第二自变量中第二个元素4的次数重复， 结果相当于`c(1,1,3,3,3,3)`。

如果希望重复完一个元素后再重复另一元素，用`each=`选项， 比如`rep(c(1,3), each=2)`结果相当于`c(1,1,3,3)`。

有一点技术性的小问题： `1:5`和`seq(5)`的结果是整型（integer）的， `c(1,3,5)`和`seq(1, 5, by=2)`的结果是浮点型（double）的。





逻辑型是R的基本数据类型之一，只有两个值TRUE和FALSE, 缺失时为NA。逻辑值一般产生自比较，如

```
sele <- (log10(15) < 2); print(sele)
## [1] TRUE
```

向量比较结果为逻辑型向量。如

```
c(1, 3, 5) > 2
## [1] FALSE  TRUE  TRUE
```

```
(1:4) >= (4:1)
## [1] FALSE FALSE  TRUE  TRUE
```

从例子可以看出，向量比较也遵从R的向量间运算的一般规则： 向量与标量的运算是向量每个元素与标量都分别运算一次， 等长向量的运算时对应元素的运算， 不等长但长度为倍数关系的向量运算是把短的从头重复利用。

与NA比较产生NA，如

```
c(1, NA, 3) > 2
## [1] FALSE    NA  TRUE
```

```
NA == NA
## [1] NA
```

为了判断向量每个元素是否NA， 用`is.na()`函数，如

```
is.na(c(1, NA, 3) > 2)
## [1] FALSE  TRUE FALSE
```

用`is.finite()`判断向量每个元素是否Inf值。

比较运算符包括

```
<   <=  >  >=  ==  !=  %in%
```

分别表示小于、小于等于、大于、大于等于、等于、不等于、属于。 要注意等于比较用了两个等号。

`%in%`是比较特殊的比较， `x %in% y`的运算把向量y看成集合， 运算结果是一个逻辑型向量， 第个元素的值为x的第元素是否属于y的逻辑型值。 如

```
c(1,3) %in% c(2,3,4)
## [1] FALSE  TRUE
```

```r
c(NA,3) %in% c(2,3,4)
## [1] FALSE  TRUE
```

```r
c(1,3) %in% c(NA, 3, 4)
## [1] FALSE  TRUE
```

```r
c(NA,3) %in% c(NA, 3, 4)
## [1] TRUE TRUE
```

函数`match(x, y)`起到和`x %in% y`运算类似的作用， 但是其返回结果不是找到与否， 而是对`x`的每个元素， 找到其在`y`中首次出现的下标，找不到时取缺失值，如

```r
match(c(1, 3), c(2,3,4,3))
## [1] NA  2
```





`substr(x, start, stop)`从字符串x中取出从第start个到第stop个的子串， 如



```
substr('JAN07', 1, 3)
## [1] "JAN"
```

如果x是一个字符型向量，`substr`将对每个元素取子串。如



```
substr(c('JAN07', 'MAR66'), 1, 3)
## [1] "JAN" "MAR"
```

用`substring(x, start)`可以从字符串x中取出从第start个到末尾的子串。如



```
substring(c('JAN07', 'MAR66'), 4)
## [1] "07" "66"
```





用`as.numeric()`把内容是数字的字符型值转换为数值，如



```
substr('JAN07', 4, 5)
## [1] "07"
substr('JAN07', 4, 5) + 2000
## Error in substr("JAN07", 4, 5) + 2000 : 
##   non-numeric argument to binary operator
as.numeric(substr('JAN07', 4, 5)) + 2000
## [1] 2007
as.numeric(substr(c('JAN07', 'MAR66'), 4, 5))
## [1]  7 66
```

`as.numeric()`是向量化的， 可以转换一个向量的每个元素为数值型。

用`as.character()`函数把数值型转换为字符型，如



```
as.character((1:5)*5)
## [1] "5"  "10" "15" "20" "25"
```

如果自变量本来已经是字符型则结果不变。

为了用指定的格式数值型转换成字符型， 可以使用`sprintf()`函数， 其用法与C语言的`sprintf()`函数相似， 只不过是向量化的。例如



```
sprintf('file%03d.txt', c(1, 99, 100))
## [1] "file001.txt" "file099.txt" "file100.txt"
```



### r向量下标和子集

负下标表示扣除相应的元素后的子集，如



```
x <- c(1,4,6.25)
x[-2]
## [1] 1.00 6.25
```



```
x[-c(1,3)]
## [1] 4
```

负整数下标不能与正整数下标同时用来从某一向量中取子集， 比如，`x[c(1,-2)]`没有意义。



设向量`x`长度为, 则使用正整数下标时下标应在中取值。 如果使用大于的下标， 读取时返回缺失值，并不出错。 给超出的下标元素赋值， 则向量自动变长， 中间没有赋值的元素为缺失值。 例如



```
x <- c(1,4,6.25)
x[5]
## [1] NA
```



```
x
## [1] 1.00 4.00 6.25
```



```
x[5] <- 9
x
## [1] 1.00 4.00 6.25   NA 9.00
```

虽然R的语法对下标超界不视作错误， 但是这样的做法往往来自不良的程序思路， 而且对程序效率有影响， 所以实际编程中应避免下标超界。

下标可以是与向量等长的逻辑表达式， 一般是关于本向量或者与本向量等长的其它向量的比较结果，如



```
x <- c(1,4,6.25)
x[x > 3]
## [1] 4.00 6.25
```

取出x的大于3的元素组成的子集。

逻辑下标除了用来对向量取子集， 还经常用来对数据框取取子集， 也用在向量化的运算中。 例如，对如下示性函数



输入向量x，结果y需要也是一个向量，程序可以写成





```
f <- function(x){
  y <- numeric(length(x))
  y[x >= 0] <- 1
  y[x < 0] <- 0 # 此语句多余
  
  y
}
```

事实上，向量化的逻辑选择有一个`ifelse()`函数， 比如，对上面的示性函数， 如果x是一个向量， 输出y向量可以写成`y <- ifelse(x>=0, 1, 0)`。

要注意的是，如果逻辑下标中有缺失值， 对应结果也是缺失值。 所以，在用逻辑下标作子集选择时， 一定要考虑到缺失值问题。正确的做法是加上`!is.na`前提， 如



```
x <- c(1, 4, 6.25, NA)
x[x > 2]
## [1] 4.00 6.25   NA
```



```
x[!is.na(x) & x > 2]
## [1] 4.00 6.25
```







### R储存模式与基本类型

注意因子的结果是`integer`而不是因子。

R还有两个函数`mode()`和`storage.mode()`起到与`typeof()`类似的作用， 这是为了提供与S语言兼容所遗留的， 应停止使用。

R中数据的最基本的类型包括logical, integer, double, character, complex, raw, 其它数据类型都是由基本类型组合或转变得到的。 character类型就是字符串类型， raw类型是直接使用其二进制内容的类型。 为了判断某个向量`x`保存的基本类型， 可以用`is.xxx()`类函数， 如`is.integer(x)`, `is.double(x)`, `is.numeric(x)`, `is.logical(x)`, `is.character(x)`, `is.complex(x)`, `is.raw(x)`。 其中`is.numeric(x)`对integer和double内容都返回真值。

在R语言中数值一般看作double, 如果需要明确表明某些数值是整数， 可以在数值后面附加字母L，如

对double类型，可以用`is.finite()`判断是否有限值， `NA`、`Inf`, `-Inf`和`NaN`都不是有限值； 用`is.infinite()`判断是否`Inf`或`-Inf`； `is.na()`判断是否`NA`或`NaN`； `is.nan()`判断是否`NaN`。

严格说来， `NA`表示逻辑型缺失值， 但是当作其它类型缺失值时一般能自动识别。 `NA_integer_`是整数型缺失值， `NA_real_`是double型缺失值， `NA_character_`是字符型缺失值。

在R的向量类型中， integer类型、double类型、logical类型、character类型、还有complex类型和raw类型称为原子类型(atomic types)， 原子类型的向量中元素都是同一基本类型的。 比如， double型向量的元素都是double或者缺失值。

除了原子类型的向量， 在R语言的定义中， 向量还包括后面要讲到的列表（list）， 列表的元素不需要属于相同的基本类型， 而且列表的元素可以不是单一基本类型元素。 用`typeof()`函数可以返回向量的类型， 列表返回结果为`"list"`:



## strings



a





















